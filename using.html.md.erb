---
breadcrumb: App Metrics Documentation
title: Monitoring and Troubleshooting Apps with App Metrics
owner: App Metrics
list_style_none: true
---

This topic describes how developers can monitor and troubleshoot their apps using App Metrics.

## <a id="overview"></a> Overview

App Metrics helps you understand and troubleshoot the health and performance of your apps by offering the following indicators, data, and visualizations:

* [Latency](#latency): Response times for your application
* [Traffic](#traffic): Number of requests made for your application
* [Errors](#errors): HTTP errors thrown by your application
* [Saturation (Container Metrics)](#saturation): Three charts measuring CPU, memory, and disk consumption percentages
* [Custom Metrics](#custom-metrics): User-customizable charts for measuring app performance, such as Spring Boot Actuator and Micrometer metrics, or user-defined custom business metrics
* [App Events](#events): A chart of update, start, stop, crash, SSH, and staging failure events
* [Logs](#logs): A list of app logs that you can search, filter, and download

The following sections describe a standard workflow for using App Metrics to monitor or troubleshoot your apps.

##<a id='get-started'></a> View an App

In a browser, navigate to `appmetrics.YOUR-SYSTEM-DOMAIN` and log in with your User Account and Authentication (UAA) credentials. Choose an app from the search bar for which you want to view metrics and/or logs. App Metrics respects UAA permissions such that you can view any app that runs in a space that you have access to.

App Metrics displays app data for a given time frame. See the sections below to [Change the Time Frame](#time) for the dashboard.

## <a id="time"></a>Change the Time Frame

The charts show time along the horizontal axis. You can change the time frame for all charts and the logs by using the time selector options at the top of the window. You can select from several pre-set timescales or select a custom date range.

**Zoom**: From within any chart, click and drag to zoom in on areas of interest. This adjusts all of the charts, and the logs, to show data from that time frame.

## <a id="auto-refresh"></a>Auto-Refreshing the Dashboard

Auto-refresh mode allows the metrics charts and logs on your dashboard to be updated on a timed interval as data is ingested.

To enable auto-refresh, click the **REFRESH** button next to the time selection options on the top right of the dashboard. This will enable live updating of metrics and logs data for the currently selected timeframe.

<p class="note"><strong>Note</strong>: The default auto-refresh interval is set to one minute and is currently not configurable.</p>

## <a id="app-instance"></a>View Metrics at the Process and Application Instance Level

App Metrics relays metric data at the app process level to allow for an in-depth troubleshooting experience, even across rolling deployment. Users are able to view the app metrics related to a specific process and further drill down into specific instances within those processes, which correlates directly with the processes and app instances shown in [Apps Manager](https://docs.pivotal.io/pivotalcf/console/manage-apps.html#manage-app).

The dashboard will display metrics aggregated across all processes by default. To view metrics by specific process, select a process type from the dropdown near the upper-left of the dashboard.

With a specific process type selected, the metrics charts will display aggregate data from all instances within the selected process type.

To view metrics for the individual instances within the selected process, select the "Instances" radio button at the upper-right of the dashboard.

To view metrics for a specific app instance (or selection of specific instances), select the desired instance(s) from the legend along the bottom of any chart on the dashboard while the "Instances" radio is selected.

##<a id='metrics'></a> Interpreting Metrics

The default metrics charts included with App Metrics provide high-level indicators of the Four Golden Signals for monitoring the health of applications running on distributed systems: Latency, Traffic, Errors, Saturation.

The following sections explain how to use each of the charts on the dashboard to monitor and troubleshoot your app.
### <a id='networkMetrics'></a> Network Metrics
<p class="note"><strong>Note</strong>: If apps are not configured for network traffic,
they show No Data or zeros for the default Latency, Traffic, and Errors metrics.
</p>
#### <a id='latency'></a> Latency

* Average latency of a request in milliseconds:<br><br>A spike in response time means your users are waiting longer. Scaling app instances can spread that workload over more resources and result in faster response times.

#### <a id='traffic'></a> Traffic

* Number of network requests per minute:<br><br>A spike in HTTP requests means more users are using your app. Scaling app instances can reduce the response time.

#### <a id='errors'></a> Errors

* Number of network request errors per minute:<br><br>A spike in HTTP errors means one or more 5xx errors have occurred. Check your app logs for more information.


### <a id='saturation'></a> Saturation (Container Metrics)

The following **Container Metrics** charts are available on the App Metrics dashboard to help monitor resource saturation:

* CPU usage percentage:<br><br>A spike in CPU might point to a process that is computationally heavy. Scaling app instances can relieve the immediate pressure, but you need to investigate the app to better understand and fix the root cause.<br><br>

* Memory usage percentage:<br><br>A consistent, gradual increase in memory might mean a resource leak in the code. Scaling app memory can relieve the immediate pressure, but you need to find and resolve the underlying issue so that it does not occur again.<br><br>

* Disk usage percentage:<br><br>A spike in disk might mean the app is writing logs to files instead of STDOUT, caching data to local disk, or serializing large sessions to disk.

### <a id='events'></a> Events

In addition, the **Events** chart helps to correllate these metrics to events for your app, including: **Crash**, **Fail** (staging failures), **Update**, **Stop**, **Start**, and **SSH**.

<p class="note"><strong>Note</strong>: The <b>SSH</b> event corresponds to someone successfully using SSH to access a container that runs an instance of the app.</p>

See the following topics for more information about app events:

* [About Starting Applications](https://docs.pivotal.io/pivotalcf/devguide/deploy-apps/start-restart-restage.html)
* [Troubleshooting Application Deployment and Health](https://docs.pivotal.io/pivotalcf/devguide/deploy-apps/troubleshoot-app-health.html)

##<a id='custom-metrics'></a> Adding Custom Metrics Charts

You can add custom metrics charts to your dashboard, including Spring Boot Actuator and Micrometer metrics, by defining the custom metrics you want to monitor and including them in an indicator document for your application.

In order to get custom, Actuator, or Micrometer metrics into the Metrics Store, you will need to bind Metric Registrar to your app and register your endpoint. For more information, see [Configuring the Metric Registrar](https://docs.pivotal.io/pivotalcf/metric-registrar/index.html).

If you want to view custom metrics, you can configure your apps to emit those metrics out of the [Loggregator Firehose](https://docs.pivotal.io/pivotalcf/loggregator/architecture.html#firehose) and then view these metrics on the App Metrics dashboard.

In addition, Spring Boot apps with actuators or Micrometer metrics implemented emit [these metrics](https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-metrics.html) out of the box, without any changes to source code.

### Creating an Indicator Document
An indicator document is a YAML document that specifies which application you want to monitor and the indicators
you want to use to monitor it.

There are 3 steps to creating an indicator document:
1. Finding the metric you want to monitor
1. Writing the PromQL query
1. Adding the PromQL to your Indicator Document

#### Finding the metric name
First verify that the metrics are being emitted. Once you have configured Metrics Registrar to scrape your metrics
endpoint, you can check your respective endpoint for metric names.

If you are using a Prometheus-style metrics endpoint, you can do so by hitting your app's metrics endpoint at
`app.domain/metrics` and looking for the desired metric.

To validate Spring Boot Actuator and Micrometer metrics, please see the
[Spring Boot documentation](https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-metrics.html).

#### Writing the PromQL
Once you have the metric name, you want to write a PromQL query that is useful for visualizing the metric.

Additional example PromQL can in the upper-right of any chart, or by visiting the
also be found for any of the default charts on the dashboard by clicking the `Info` menu
[PromQL Query Examples](https://prometheus.io/docs/prometheus/latest/querying/examples/) documentation.

To test out PromQL before putting it in an indicator document, there is a PromQL Explorer that is accessible by
the + button at the bottom right of the dashboard. With the PromQL Explorer, you can test out queries and see what
the resulting graph would look like before placing it in an indicator document for more permanent persistence.

<p class="note"><strong>Note</strong>: PromQL should always have the <code>source_id</code> tag for non-admin users.
  App Metrics supports using a <code>$sourceId</code> parameter in the PromQL which will automatically refer to the sourceId of
  the current application. Example: <code>cpu{source_id="$sourceId"}</code>
</p>

#### Adding the PromQL to your Indicator Document
Once you have the PromQL ready, you're ready to put it in an Indicator Document.

For example, say you had a custom metric `customMetricName500` and wanted to graph the amount of errors over a 1 minute
period, so your PromQL query is `sum(avg_over_time(customMetricName500{source_id=\"$sourceId\"}[1m]))`.
The following is an example of the YAML for an indicator document:
<pre>
---
apiVersion: indicatorprotocol.io/v1
kind: IndicatorDocument

metadata:
  labels:
    deployment: "my deployment name"

spec:
  product:
    name: org,space,app-name
    version: 0.0.1

  indicators:
    - name: CustomErrorCount500
      promql: "sum(rate(customMetricName500{source_id='$sourceId'}[1m]))"
      documentation:
        title: "Custom Metric 500 Errors"
      presentation:
        units: "none"
</pre>

Please note that `org,space,app-name` above is responsible for defining which application these indicators will be
applied to. Please replace this with the org, space, and app name of the application dashboard you wish to customize.

#### Indicator Document Schema

App Metrics uses a reduced version of the Indicator Protocol. For more information on the App Metrics-supported
indicator document schema, see [Indicator Document API Spec](#indicator-document-api-spec).

For more information about the full schema of indicator documents, please see the [Indicator Protocol Document Reference](https://github.com/pivotal/monitoring-indicator-protocol/wiki/Indicator-Document-Reference).

<p class="note"><strong>Note</strong>: At this time, only the <code>name</code>, <code>promql</code>,
   <code>documentation</code>, and <code>presentation</code> fields are supported for application indicators.
</p>

### cURLing Your Indicator Document to App Metrics
Once you have created your indicator document, you can push it to App Metrics via cURL.

Linux/Mac:
<pre>curl -vvv https://appmetrics.sys.DOMAIN/indicator-documents -H "Authorization: $(cf oauth-token)" --data-binary "@[YourDoc.yml]"</pre>

Windows:
<ol>
  <li> Copy your cf oath token to the clipboard: `cf oauth-token`</li>
  <li> Paste your oauth token into the following command:</li>
</ol>
<pre>curl -vvv https://appmetrics.sys.DOMAIN/indicator-documents -H "Authorization: [YOUR TOKEN]" --data-binary "@[YourDoc.yml]"</pre>

<p class="note"><strong>Note</strong>: You can only push indicators for applications that run in a space that you have access to.</p>

Once you have your indicator document created, you can also automate the deployment of application indicator documents within your deployment pipeline.

#### <a id="indicator-document-api-spec"></a> Indicator Document API spec
In short, there is a `/indicator-documents` path that supports `POST` and an `/indicator-documents/{org,space,app}` that
supports deleting an indicator document for a specific `org,space,app`.

Deleting or uploading an indicator document will clear all associated monitors and recorded alerts associated with
that application.

For more details on the indicator document API, consult the following Open API specification. To use demos and
examples, you can test it out in the [Swagger Editor](https://editor.swagger.io/).

<pre>
openapi: 3.0.2
info:
  title: App Metrics API for Indicator Documents
  version: '1.0'
paths:
  /indicator-documents:
    post:
      description: POST document
      requestBody:
        description: YAML file containing the Indicator Document
        required: true
        content:
          text/yaml;charset=utf-8:
            schema:
              $ref: '#/components/schemas/IndicatorDocument'
            examples:
              errorCountExample:
                $ref: '#/components/examples/IndicatorDocumentExample'
      responses:
        '200':
          description: OK
        '400':
          description: Invalid indicator document format
        '401':
          description: Invalid Authorization header
        '404':
          description: Product name not found
  '/indicator-documents/{productName}':
    parameters:
      - name: productName
        in: path
        required: true
        description: product name associated with the indicator document to delete
        schema:
          type: string
    delete:
      description: DELETE document
      responses:
        '204':
          description: OK
        '401':
          description: Invalid Authorization header
        '404':
          description: Product name not found
components:
  schemas:
    IndicatorDocument:
      type: object
      required:
        - apiVersion
        - kind
        - spec
      properties:
        apiVersion:
          type: string
          enum:
            - indicatorprotocol.io/v1
        kind:
          type: string
          enum:
            - IndicatorDocument
        metadata:
          type: object
          properties:
            name:
              type: string
            labels:
              type: object
        spec:
          type: object
          required:
            - product
          properties:
            product:
              type: object
              required:
                - name
                - version
              properties:
                name:
                  type: string
                  minLength: 1
                version:
                  type: string
                  minLength: 1
            indicators:
              type: array
              items:
                type: object
                required:
                  - name
                  - promql
                properties:
                  name:
                    type: string
                    pattern: '[a-zA-Z_:][a-zA-Z0-9_:]*'
                  promql:
                    type: string
                    minLength: 1
                  presentation:
                    type: object
                    properties:
                      chartType:
                        type: string
                        enum:
                          - step
                          - bar
                          - status
                          - quota
                      currentValue:
                        type: boolean
                      frequency:
                        type: integer
                      labels:
                        type: array
                        items:
                          type: string
                      units:
                        type: string
                        enum:
                          - none
                          - bytes
                          - counts
                          - percentage
                        description: |
                          The units are responsible for automatic formatting of chart data. bytes will automatically be
                          converted to kB, MB, GB, or TB as appropriate. counts will be converted to K or M as appropriate.
                          percentage will be formatted as a percentage. none will round to 2 decimals.
                  documentation:
                    type: object
                    properties:
                      title:
                        type: string
                        description: Title that the chart will display
                      description:
                        type: string
                        description: What is the chart trying to display?
                      recommendedMeasurement:
                        type: string
                        description: 'Explanation of time frame, PromQL query in general'
                      recommendedResponse:
                        type: string
                        description: Troubleshooting information
                      thresholdNote:
                        type: string
                        description: Explanations for why the thresholds exist
  examples:
    IndicatorDocumentExample:
      description: |
        An indicator document specifying one custom indicator called CustomErrorCount500 for the
        application `org,space,app`.

        It will graph the 1 minute average errors as reported by the custom metric `customMetricName500`. The
        `$sourceId` will be interpolated to the source_id of the app at rendering time.

        The title of the graph will display as "Custom Metric 500 Errors".
      value: |
        ---
        apiVersion: indicatorprotocol.io/v1
        kind: IndicatorDocument

        metadata:
          labels:
            deployment: "my deployment name"

        spec:
          product:
            name: org,space,app-name
            version: 0.0.1

          indicators:
            - name: CustomErrorCount500
              promql: "sum(rate(customMetricName500{source_id='$sourceId'}[1m]))"
              documentation:
                title: "Custom Metric 500 Errors"
              presentation:
                units: "counts"
</pre>

##<a id='monitoring'></a> Adding Monitoring and Alerting

You can add custom monitoring to your dashboard's indicators by creating a custom monitor document for your application.

### Creating a Monitor Documents
Monitors are linked to specific indicators, so the first step to adding custom monitoring and alerting to your
application is to verify the names of the indicators you would like to monitor.

You can view the indicator names of each chart on your application's dashboard by hovering on the desired chart,
clicking on the kabobs in the right-hand corner and selecting Info.

The indicator name can correspond to one of your custom indicators or to one of the default indicator names:
RequestCount, HttpLatency, ErrorCount, CPU, MemoryPercentage, and DiskPercentage.

Once you have the indicator names you can create your monitor document that will define threshold for your indicator
and the webhook to send alerts to. The following is an example of the YAML for an monitor document:

<pre>
---
product: org,space,app-name

slack_webhook_url: https://my-slack-webhook.com

monitors:
  - name: 500 Errors For Application
    indicator: ErrorCount
    warning:
       operator: gte
       threshold: 1.0
       duration: 1m
       only_every: 1h
    critical:
       operator: gte
       threshold: 2.0
       duration: 1m
       only_every: 15m
</pre>

Please note that `org,space,app-name` above is responsible for defining which application these indicators will be applied to.
Please replace this with the org, space, and app name of the application you wish to monitor.

Please also note that the `https://my-slack-webhook.com` should be where alerts are sent when a threshold is surpassed.
Slack is the currently the only supported use case, but other webhook platforms may work if they accept a "text" payload.

#### Monitor Document Schema
For more detailed information on the monitor document schema, see the [Monitor Document API spec](#monitoring-document-api-spec).

### cURLing Your Monitor Document to App Metrics
Once you have your monitor document prepared, you can push it to App Metrics via cURL.
The flow is the same as the indicator document flow but curling to the `/monitor-documents` endpoint.

Linux/Mac:
<pre>curl -vvv https://appmetrics.sys.DOMAIN/monitor-documents -H "Authorization: $(cf oauth-token)" --data-binary "@[YourDoc.yml]"</pre>

Windows:
<ol>
  <li> Copy your cf oath token to the clipboard: `cf oauth-token`</li>
  <li> Paste your oauth token into the following command:</li>
</ol>
<pre>curl -vvv https://appmetrics.sys.DOMAIN/monitor-documents -H "Authorization: [YOUR TOKEN]" --data-binary "@[YourDoc.yml]"</pre>

<p class="note"><strong>Note</strong>: You can only push monitors for applications that run in a space that you have access to.</p>

Once you have your monitor document created, you can also automate the deployment of application monitor documents within your deployment pipeline.

#### <a id='monitoring-document-api-spec'></a> Monitor Document API spec
In short, there is a `/monitors-documents` path that supports `POST` and an `/monitor-documents/{org,space,app}` that
supports `GET` a monitor document for a specific `org,space,app`. There is currently no `DELETE` supported for a single
monitors document. However, a monitors document will get deleted when a new indicator file is uploaded for that
application.

For more details on the monitor document API, consult the following Open API specification. To use demos and
examples, you can test it out in the [Swagger Editor](https://editor.swagger.io/).

<pre>
openapi: 3.0.2
info:
  title: App Metrics API for Monitor Documents
  version: '1.0'
paths:
  /monitor-documents:
    post:
      description: POST document
      requestBody:
        description: YAML file containing the Monitor Document
        required: true
        content:
          text/yaml;charset=utf-8:
            schema:
              $ref: '#/components/schemas/MonitorDocument'
            examples:
              errorCountExample:
                $ref: '#/components/examples/MonitorDocumentExample'
      responses:
        '200':
          description: OK
        '400':
          description: Invalid monitor document format
        '401':
          description: Invalid Authorization header
        '404':
          description: Product name not found
  '/monitor-documents/{productName}':
    parameters:
      - name: productName
        in: path
        required: true
        description: product name associated with the indicator document to delete
        schema:
          type: string
    get:
      description: GET monitor document
      responses:
        '200':
          description: fetched document successfully
        '400':
          description: No product name supplied
        '401':
          description: Invalid Authorization header
        '404':
          description: Product name not found
components:
  schemas:
    MonitorDocument:
      type: object
      required:
        - product
        - monitors
      properties:
        product:
          type: string
          description: 'org,space,app name for the application to be monitored'
        monitors:
          type: array
          items:
            $ref: '#/components/schemas/Monitor'
        webhook_url:
          type: string
          description: URL of webhook to receive JSON payload when alerts are triggered
    Monitor:
      type: object
      required:
        - name
        - indicator
      properties:
        name:
          type: string
        indicator:
          type: string
          description: |
            Name of the indicator this monitor corresponds to. It could be the name of a custom indicator or one of the
            following default indicators: {RequestCount, HttpLatency, ErrorCount, CPU, MemoryPercentage, DiskPercentage}
        warning:
          description: Threshold at which warning notifications should go off
          $ref: '#/components/schemas/MonitorThreshold'
        critical:
          description: Threshold at which critical notifications should go off
          $ref: '#/components/schemas/MonitorThreshold'
    MonitorThreshold:
      type: object
      required:
        - operator
        - threshold
        - duration
        - only_every
      properties:
        operator:
          type: string
          enum:
            - lt
            - lte
            - gt
            - gte
            - eq
            - neq
        threshold:
          type: number
        duration:
          type: string
          description: How long the value has to be past the threshold before firing an alert.
        only_every:
          type: string
          description: 'Minimum duration between alerts. Alerts will fire only every [this duration].'
  examples:
    MonitorDocumentExample:
      description: |
        A monitor on the ErrorCount indicator for the system,catalyst,appmetrics application that sends alerts to
        https://my-slack-webhook.com.

        A warning alert gets sent when the ErrorCount is greater than 1 for a duration of at least one minute, and will
        only get sent a maximum of once every hour.

        A critical alert will get sent when the ErrorCount is greater than 2 for a duration of at least one minute,
        and will only get sent a maximum of every fifteen minutes.
      value: |
        ---
        product: system,catalyst,appmetrics

        slack_webhook_url: https://my-slack-webhook.com

        monitors:
          - name: 500 Errors For Application
            indicator: ErrorCount
            warning:
               operator: gte
               threshold: 1.0
               duration: 1m
               only_every: 1h
            critical:
               operator: gte
               threshold: 2.0
               duration: 1m
               only_every: 15m
</pre>

### Custom Metric Demos

* [Adding custom application metric charts using Indicator Protocol](https://www.youtube.com/watch?v=KKed-LwJ0BM)
* [Creating a custom dashboard to monitor multiple applications](https://www.youtube.com/watch?v=d1gtLtdiOa4)
* [Platform-level metric charts to the dashboard](https://www.youtube.com/watch?v=z7CVbYzjxVU)

##<a id="logs"></a>Logs

The **Logs** view displays app log data ingested from the Loggregator Reverse Log Proxy (RLP):

<p class="note"><strong>Note</strong>: Logs with non-UTF-8 characters or non-standard UUID application GUIDs are not stored.</p>

You can interact with the **Logs** view in the following ways:

* **Keyword**: Perform a keyword search. While filtering on keywords, logs results will be reduced to only display log lines that contain the matching criteria. Matching terms will also be highlighted in blue.
* **Highlight**: Enter a term to visually highlight within your search. The terms will be highlighted in orange within the current filter results.
* **Sources**: Choose which sources to display logs from. For more information, see [Log Types and Their Messages](https://docs.pivotal.io/pivotalcf/devguide/deploy-apps/streaming-logs.html#format).
* **Download**: Download a file containing logs for the current search.
* **Copy**: Click the copy icon to copy the text of the log.

By default, the most recent 1,000 log lines will be displayed in the logs drawer. You can click `SHOW 1000 MORE LOGS` to load more.

##<a id="direct-data-access"></a> Direct Data Access

You can query Metric Store and Log Store directly to access the raw data.

### <a id="metric-store-api"></a> Metric Store API

To query Metric Store, consult the documentation for [Using Metric Store](https://docs.pivotal.io/metric-store/using.html)

### <a id="log-store-api"></a> Log Store API

#### <a id='prerequisites'></a> Prerequisites

- [curl](https://github.com/curl/curl)
- [CF Auth Token](https://docs.cloudfoundry.org/cf-cli/install-go-cli.html)

#### <a id='authorization-authentication'></a> Authorization & Authentication

When querying the API via HTTPS, each request must have the `Authorization`
header set with a UAA provided token.

#### <a id='querying'></a> Querying via HTTP Endpoints

**GET** `/v1/sources/{sourceID}/logs`

Issues a query against Log Store data.

Path Parameters:
- **sourceID** -- The application or component source ID. Application source ID is the same as application GUID.

Query Parameters:

- **query** is a [PromQL label selector query](https://prometheus.io/docs/prometheus/latest/querying/basics/#querying-prometheus) for filtering logs on  `message`, `message_type`, `source_type`, and `instance_id`.
  - `message` -- RegEx to search the log message body
  - `message_type` -- The file descriptor the log was written to, `OUT` or `ERR`
  - `source_type` -- The source of the log, any subset of `{"API","APP","CELL","HEALTH","LGR","RTR","SSH","STG"}` connected by pipes, e.g. `"APP|API"`.
  - `instance_id` -- Filter based on the instance ID of the application or component that wrote the log
- **startTime** is an optional UNIX timestamp in nanoseconds or RFC3339. Defaults to 10 minutes ago. Must be before end time.
- **endTime** is an optional UNIX timestamp in nanoseconds or RFC3339. Defaults to now. Must be after start time.
- **limit** is an optional maximum number of logs to return. Defaults to 100.
- **page** is an optional number of the page of logs to be returned, must be `>= 1`. Defaults to 1.
- **order** is an optional order in which the logs will be returned, `asc` or `desc`. Defaults to `desc`.

```shell
export SYSTEM_DOMAIN="<YOUR_SYSTEM_DOMAIN>"
export SOURCE_ID="$(cf app <YOUR_APP> --guid)"
curl -XGET -H "Authorization: $(cf oauth-token)" \
     "https://log-store.$YOUR_SYSTEM_DOMAIN/v1/sources/$SOURCE_ID/logs" \
     --data-urlencode 'query={message=~"Error.*"}'
```

**Response Body**

```json
{
  "metadata": {
    "count": 1,
    "links": {}
  },
  "items": [
    {
      "instance_id": "0",
      "message": "Error: Sample query didn't work",
      "message_type": "OUT",
      "source_id": "50efa176-bd06-42d1-bac8-672aab387e75",
      "source_type": "APP/PROC/WEB",
      "timestamp": "2020-03-24T06:57:29.788299446Z"
    }
  ]
}
```
